<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
    <title>Bubble Buzzle</title>
    <style>
        html, body { height: 100%; }
        body { margin: 0; background: #0f1226; overscroll-behavior: none; }
        * { box-sizing: border-box; }
        #game { touch-action: manipulation; }
        /* Responsive header sizes */
        .hud { padding: 10px; }
        .hud button { font-size: 14px; padding: 8px 16px; }
        .hud .label { font-size: 16px; }
        @media (max-width: 600px) {
            .hud { padding: 8px; }
            .hud button { font-size: 13px; padding: 8px 14px; }
            .hud .label { font-size: 14px; }
        }
    </style>
</head>
<body>
    <!-- Bubble Buzzle Game - Full Screen Mobile/Desktop -->
    <div style="background:#0f1226;padding:0;margin:0;width:100vw;height:100vh;box-sizing:border-box;position:relative;overflow:hidden;">
        
        <!-- Game Header -->
        <div class="hud" style="position:absolute;top:0;left:0;right:0;z-index:10;background:rgba(15,18,38,0.9);text-align:center;">
            <button id="restart" style="background:#3f5efb;color:#fff;border:none;border-radius:6px;cursor:pointer;margin:0 10px;">Restart</button>
            <span class="label" style="color:#fff;margin:0 15px;">Score: <span id="score">0</span></span>
            <span class="label" style="color:#fff;margin:0 15px;">Shots: <span id="shots">0</span></span>
        </div>
        
        <!-- Game Canvas - Takes full screen -->
        <canvas id="game" style="width:100vw;height:100vh;display:block;background:radial-gradient(1200px 600px at 50% 20%, #1a1f4a, #0f1226);"></canvas>
        
        <!-- Instructions -->
        <div style="position:absolute;bottom:10px;left:50%;transform:translateX(-50%);color:#fff;opacity:0.7;font-size:12px;text-align:center;z-index:10;">
            Touch or click to aim and shoot â€¢ Press R to restart
        </div>
    </div>

<script>
(function(){
    if(window.BubbleGameMobileLoaded) return;
    window.BubbleGameMobileLoaded = true;
    
    const canvas = document.getElementById('game');
    if(!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const restartBtn = document.getElementById('restart');
    const scoreEl = document.getElementById('score');
    const shotsEl = document.getElementById('shots');

    // Core game variables declared before resize to avoid TDZ
    let W = 0;
    let H = 0;
    let R = 12;
    let DIAM = R * 2;
    let COLS = 0;
    const ROWS = 15;
    const COLORS = ['#52e5ff','#ffd166','#ff6b6b','#9d4edd','#06d6a0','#f72585'];

    // Lightweight initial state; fully initialized in reset()
    const state = {
        grid: [],
        rowCount: 4,
        score: 0,
        shots: 0,
        current: null,
        aimX: 0,
        aimY: 0,
        gameOver: false
    };

    // Full screen responsive canvas with HiDPI support
    function resizeCanvas() {
        const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
        // Set backing store size for crisp rendering
        canvas.width = Math.floor(window.innerWidth * dpr);
        canvas.height = Math.floor(window.innerHeight * dpr);
        // Scale drawing so coordinates use CSS pixels
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        
        // Update global variables
        W = window.innerWidth;
        H = window.innerHeight;
        
        // Adjust bubble size based on screen size
        const screenSize = Math.min(W, H);
        if(screenSize < 400) {
            R = 8;
            DIAM = R * 2;
        } else if(screenSize < 600) {
            R = 10;
            DIAM = R * 2;
        } else {
            R = 12;
            DIAM = R * 2;
        }
        
        // Recalculate columns after R/DIAM are set
        COLS = Math.max(1, Math.floor((W - R) / DIAM));
    }
    
    // Initial resize
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    function reset(){
        state.grid = Array(ROWS).fill().map(() => Array(COLS).fill(null));
        state.rowCount = 4;
        state.score = 0;
        state.shots = 0;
        state.gameOver = false;
        state.aimX = W/2;
        state.aimY = H-40;
        
        // Fill initial rows
        for(let r=0; r<state.rowCount; r++){
            for(let c=0; c<COLS; c++){
                if(Math.random() < 0.8) {
                    state.grid[r][c] = COLORS[Math.floor(Math.random() * COLORS.length)];
                }
            }
        }
        
        state.current = {
            x: W/2,
            y: H-30,
            vx: 0,
            vy: 0,
            color: COLORS[Math.floor(Math.random() * COLORS.length)],
            moving: false
        };
        
        updateHud();
    }

    function updateHud(){
        if(scoreEl) scoreEl.textContent = state.score;
        if(shotsEl) shotsEl.textContent = state.shots;
    }

    function shootTowards(mx, my){
        if(state.gameOver || !state.current || state.current.moving) return;
        
        const dx = mx - state.current.x;
        const dy = my - state.current.y;
        const len = Math.hypot(dx, dy) || 1;
        
        state.current.vx = (dx/len) * 350;
        state.current.vy = (dy/len) * 350;
        state.current.moving = true;
        state.shots++;
        updateHud();
    }

    function placeBall(){
        const { r, c } = worldToGrid(state.current.x, state.current.y);
        const rr = Math.max(0, Math.min(ROWS-1, r));
        const cc = Math.max(0, Math.min(COLS-1, c));
        
        if(!state.grid[rr][cc]){
            state.grid[rr][cc] = state.current.color;
            state.current = {
                x: W/2,
                y: H-30,
                vx: 0,
                vy: 0,
                color: COLORS[Math.floor(Math.random() * COLORS.length)],
                moving: false
            };
            checkMatches(rr, cc);
            addRowIfNeeded();
        }
    }

    function worldToGrid(x, y){
        const r = Math.max(0, Math.round((y - R) / (R * 1.8)));
        const c = Math.round((x - R) / DIAM);
        return { r, c };
    }

    function gridToWorld(r, c){
        return {
            x: R + c * DIAM,
            y: R + r * (R * 1.8)
        };
    }

    function checkMatches(sr, sc){
        const color = state.grid[sr][sc];
        if(!color) return;
        
        const cluster = [];
        const visited = new Set();
        const queue = [[sr, sc]];
        
        while(queue.length){
            const [r, c] = queue.shift();
            if(visited.has(r+','+c)) continue;
            visited.add(r+','+c);
            cluster.push([r, c]);
            
            // Check neighbors
            const neighbors = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
            for(const [nr, nc] of neighbors){
                if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS && 
                   !visited.has(nr+','+nc) && state.grid[nr][nc] === color){
                    queue.push([nr, nc]);
                }
            }
        }
        
        if(cluster.length >= 3){
            for(const [r, c] of cluster){
                state.grid[r][c] = null;
            }
            state.score += cluster.length * 10;
            updateHud();
        }
    }

    function addRowIfNeeded(){
        if(state.shots > 0 && state.shots % 6 === 0){
            if(state.rowCount >= ROWS - 2){
                state.gameOver = true;
                return;
            }
            
            // Move rows down
            for(let r = state.rowCount; r > 0; r--){
                state.grid[r] = [...state.grid[r-1]];
            }
            
            // Add new row at top
            state.grid[0] = Array(COLS).fill().map(() => 
                Math.random() < 0.7 ? COLORS[Math.floor(Math.random() * COLORS.length)] : null
            );
            state.rowCount++;
        }
    }

    function update(dt){
        if(state.gameOver) return;
        
        const c = state.current;
        if(c && c.moving){
            c.x += c.vx * dt;
            c.y += c.vy * dt;
            
            // Bounce off walls
            if(c.x < R){ c.x = R; c.vx *= -1; }
            if(c.x > W - R){ c.x = W - R; c.vx *= -1; }
            if(c.y < R){ c.y = R; placeBall(); return; }
            
            // Check collision with grid
            for(let r = 0; r < ROWS; r++){
                for(let c = 0; c < COLS; c++){
                    if(!state.grid[r][c]) continue;
                    const {x, y} = gridToWorld(r, c);
                    const dx = state.current.x - x;
                    const dy = state.current.y - y;
                    if(dx*dx + dy*dy <= (R*1.8)*(R*1.8)){
                        placeBall();
                        return;
                    }
                }
            }
            
            if(c.y > H - 20){ placeBall(); }
        }
    }

    function draw(){
        ctx.clearRect(0, 0, W, H);
        
        // Draw grid bubbles
        for(let r = 0; r < ROWS; r++){
            for(let c = 0; c < COLS; c++){
                if(!state.grid[r][c]) continue;
                const {x, y} = gridToWorld(r, c);
                drawBubble(x, y, state.grid[r][c]);
            }
        }
        
        // Draw shooter area
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(0, H-50, W, 50);
        
        // Draw aim line
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        const c = state.current;
        if(c){
            ctx.moveTo(c.x, c.y);
            const dx = state.aimX - c.x;
            const dy = state.aimY - c.y;
            const len = Math.hypot(dx, dy) || 1;
            ctx.lineTo(c.x + (dx/len)*80, c.y + (dy/len)*80);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw current ball
        if(state.current){
            drawBubble(state.current.x, state.current.y, state.current.color);
        }
        
        // Game over screen
        if(state.gameOver){
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, W, H);
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.min(W/20, 32)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('Game Over', W/2, H/2 - 20);
            ctx.font = `${Math.min(W/30, 18)}px Arial`;
            ctx.fillText('Touch to restart', W/2, H/2 + 20);
        }
    }

    function drawBubble(x, y, color){
        const grad = ctx.createRadialGradient(x-R*0.3, y-R*0.4, 0, x, y, R);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.3, color);
        grad.addColorStop(1, 'rgba(255,255,255,0.2)');
        
        ctx.beginPath();
        ctx.arc(x, y, R, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        
        // Highlight
        ctx.beginPath();
        ctx.arc(x-R*0.3, y-R*0.4, R*0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fill();
    }

    // Enhanced touch and mouse events
    let isMouseDown = false;
    
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        state.aimX = e.clientX - rect.left;
        state.aimY = e.clientY - rect.top;
    });

    canvas.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isMouseDown = true;
        const rect = canvas.getBoundingClientRect();
        state.aimX = e.clientX - rect.left;
        state.aimY = e.clientY - rect.top;
    });

    canvas.addEventListener('mouseup', (e) => {
        if(isMouseDown) {
            shootTowards(state.aimX, state.aimY);
            isMouseDown = false;
        }
    });

    // Touch events for mobile
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        state.aimX = touch.clientX - rect.left;
        state.aimY = touch.clientY - rect.top;
    });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if(state.gameOver) {
            reset();
        } else {
            shootTowards(state.aimX, state.aimY);
        }
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        state.aimX = touch.clientX - rect.left;
        state.aimY = touch.clientY - rect.top;
    });

    document.addEventListener('keydown', (e) => {
        if(e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA'){
            if(e.key === 'r' || e.key === 'R'){
                reset();
            }
        }
    });

    if(restartBtn){
        restartBtn.addEventListener('click', reset);
    }

    // Game loop
    let lastTime = performance.now();
    function gameLoop(currentTime){
        const dt = Math.min(0.033, (currentTime - lastTime) / 1000);
        lastTime = currentTime;
        
        update(dt);
        draw();
        
        requestAnimationFrame(gameLoop);
    }

    // Start game
    reset();
    requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
